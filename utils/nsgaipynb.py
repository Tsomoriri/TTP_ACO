# -*- coding: utf-8 -*-
"""NSGAipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P3amJgYv849rYoGvnPAE3T0U-wa6PfFp
"""
import numpy as np
import random
1.

# Define the problem: Objective functions (modify these according to your needs)


def objective_function_1(x):
    return x**2


def objective_function_2(x):
    return (x - 2)**2

# Generate initial population


def generate_population(population_size):
    return [[random.random() for _ in range(2)] for _ in range(population_size)]

# Calculate fitness for each individual in the population


def calculate_fitness(population):
    return [[objective_function_1(ind[0]), objective_function_2(ind[1])] for ind in population]

# Non-dominated sorting


def non_dominated_sort(population):
    fronts = []
    domination_count = {i: 0 for i in range(len(population))}
    dominated_solutions = {i: [] for i in range(len(population))}
    fitness = calculate_fitness(population)

    for i in range(len(population)):
        for j in range(len(population)):
            if all(fitness[i][k] <= fitness[j][k] for k in range(2)) and any(fitness[i][k] < fitness[j][k] for k in range(2)):
                dominated_solutions[i].append(j)
            elif all(fitness[j][k] <= fitness[i][k] for k in range(2)) and any(fitness[j][k] < fitness[i][k] for k in range(2)):
                domination_count[i] += 1

        if domination_count[i] == 0:
            fronts.append([i])

    i = 0
    while fronts[i]:
        next_front = []
        for p in fronts[i]:
            for q in dominated_solutions[p]:
                domination_count[q] -= 1
                if domination_count[q] == 0:
                    next_front.append(q)
        i += 1
        if next_front:
            fronts.append(next_front)

    return fronts

# Crowding distance calculation within a front


def crowding_distance(front, fitness):
    distances = [0] * len(front)
    objectives = len(fitness[0])

    for obj in range(objectives):
        front.sort(key=lambda x: fitness[x][obj])
        distances[0] = distances[-1] = float('inf')

        if fitness[front[-1]][obj] - fitness[front[0]][obj] == 0:
            continue

        for i in range(1, len(front) - 1):
            distances[i] += (fitness[front[i + 1]][obj] - fitness[front[i - 1]]
                             [obj]) / (fitness[front[-1]][obj] - fitness[front[0]][obj])

    return distances

# NSGA-II algorithm


def nsga_ii(population_size, max_generations):
    population = generate_population(population_size)

    for generation in range(max_generations):
        fronts = non_dominated_sort(population)
        fitness = calculate_fitness(population)

        new_population = []
        for front in fronts:
            distances = crowding_distance(front, fitness)
            combined = list(zip(front, distances))
            combined.sort(key=lambda x: x[1], reverse=True)
            sorted_front, _ = zip(*combined)
            new_population.extend(sorted_front)

        population = [population[i] for i in new_population[:population_size]]

    return population


# Example usage
final_population = nsga_ii(population_size=50, max_generations=100)
# Further operations on the final_population
2.

# Objective functions - Replace these with your own functions


def objective_function_1(x):
    return x ** 2


def objective_function_2(x):
    return (x - 2) ** 2

# Generate initial population


def generate_population(population_size):
    return np.random.rand(population_size, 2)  # Assuming two objectives

# Calculate fitness for the population


def calculate_fitness(population):
    return np.column_stack((objective_function_1(population[:, 0]), objective_function_2(population[:, 1])))

# Check dominance between two solutions


def dominates(solution1, solution2):
    return all(sol1 <= sol2 for sol1, sol2 in zip(solution1, solution2)) \
        and any(sol1 < sol2 for sol1, sol2 in zip(solution1, solution2))

# Non-dominated sorting


def non_dominated_sort(population):
    n = len(population)
    domination_count = np.zeros(n, dtype=int)
    dominated_solutions = {i: [] for i in range(n)}
    fitness = calculate_fitness(population)

    for i in range(n):
        for j in range(n):
            if dominates(fitness[i], fitness[j]):
                dominated_solutions[i].append(j)
            elif dominates(fitness[j], fitness[i]):
                domination_count[i] += 1

    fronts = [[]]
    current_front = np.where(domination_count == 0)[0]

    while len(current_front) > 0:
        fronts[-1].extend(current_front.tolist())

        next_front = []
        for i in current_front:
            for j in dominated_solutions[i]:
                domination_count[j] -= 1
                if domination_count[j] == 0:
                    next_front.append(j)

        if len(next_front) > 0:
            fronts.append([])
            current_front = np.array(next_front)
        else:
            break

    return fronts[:-1]

# Crowding distance calculation within a front


def crowding_distance(population, front):
    distances = np.zeros(len(front))
    fitness = calculate_fitness(population)
    objectives = fitness.shape[1]

    for obj in range(objectives):
        sorted_indices = np.argsort(fitness[front, obj])
        distances[sorted_indices[[0, -1]]] = np.inf

        if fitness[front, obj][-1] - fitness[front, obj][0] == 0:
            continue

        distances[sorted_indices[1:-1]] += (fitness[front, obj][sorted_indices[2:]] - fitness[front, obj][sorted_indices[:-2]]) / (
            fitness[front, obj][-1] - fitness[front, obj][0])

    return distances

# NSGA-II algorithm


def nsga_ii(population_size, max_generations):
    population = generate_population(population_size)

    for generation in range(max_generations):
        fronts = non_dominated_sort(population)

        new_population = []
        for front in fronts:
            distances = crowding_distance(population, front)
            combined = list(zip(front, distances))
            combined.sort(key=lambda x: x[1], reverse=True)
            sorted_front, _ = zip(*combined)
            new_population.extend(sorted_front)

        population = population[new_population[:population_size]]

    return population


# Example usage
final_population = nsga_ii(population_size=50, max_generations=100)
# Further operations on the final_population

3.

# Objective functions - Replace these with your own functions


def objective_function_1(x):
    return x ** 2


def objective_function_2(x):
    return (x - 2) ** 2

# Generate initial population


def generate_population(population_size):
    return np.random.rand(population_size, 2)  # Assuming two objectives

# Calculate fitness for the population


def calculate_fitness(population):
    return np.column_stack((objective_function_1(population[:, 0]), objective_function_2(population[:, 1])))

# Perform crossover between two individuals


def crossover(parent1, parent2):
    alpha = random.random()
    return [alpha * p1 + (1 - alpha) * p2 for p1, p2 in zip(parent1, parent2)]

# Perform mutation on an individual


def mutate(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] = random.random()  # Replace with your mutation logic
    return individual

# Check dominance between two solutions


def dominates(solution1, solution2):
    return all(sol1 <= sol2 for sol1, sol2 in zip(solution1, solution2)) \
        and any(sol1 < sol2 for sol1, sol2 in zip(solution1, solution2))

# Non-dominated sorting with integrated genetic algorithm


def nsga_ii(population_size, max_generations, crossover_rate, mutation_rate):
    population = generate_population(population_size)

    for generation in range(max_generations):
        fitness = calculate_fitness(population)

        # Non-dominated sorting
        n = len(population)
        domination_count = np.zeros(n, dtype=int)
        dominated_solutions = {i: [] for i in range(n)}

        for i in range(n):
            for j in range(n):
                if dominates(fitness[i], fitness[j]):
                    dominated_solutions[i].append(j)
                elif dominates(fitness[j], fitness[i]):
                    domination_count[i] += 1

        fronts = [[]]
        current_front = np.where(domination_count == 0)[0]

        while len(current_front) > 0:
            fronts[-1].extend(current_front.tolist())

            next_front = []
            for i in current_front:
                for j in dominated_solutions[i]:
                    domination_count[j] -= 1
                    if domination_count[j] == 0:
                        next_front.append(j)

            if len(next_front) > 0:
                fronts.append([])
                current_front = np.array(next_front)
            else:
                break

        new_population = []
        for front in fronts:
            distances = np.zeros(len(front))
            for obj in range(2):  # Hardcoded for 2 objectives, modify if needed
                sorted_indices = np.argsort(fitness[front, obj])
                distances[sorted_indices[[0, -1]]] = np.inf

                if fitness[front, obj][-1] - fitness[front, obj][0] == 0:
                    continue

                distances[sorted_indices[1:-1]] += (fitness[front, obj][sorted_indices[2:]] - fitness[front, obj][sorted_indices[:-2]]) / (
                    fitness[front, obj][-1] - fitness[front, obj][0])

            combined = list(zip(front, distances))
            combined.sort(key=lambda x: x[1], reverse=True)
            sorted_front, _ = zip(*combined)
            new_population.extend(sorted_front)

        population = population[new_population[:population_size]]

        # Genetic operations - crossover and mutation
        for i in range(population_size):
            if random.random() < crossover_rate:
                parent1 = population[random.randint(0, population_size - 1)]
                parent2 = population[random.randint(0, population_size - 1)]
                child = crossover(parent1, parent2)
                population[i] = child

            population[i] = mutate(population[i], mutation_rate)

    return population


# Example usage
final_population = nsga_ii(
    population_size=50, max_generations=100, crossover_rate=0.8, mutation_rate=0.1)
# Further operations on the final_population
